/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { Contract, ContractTransaction, EventFilter, Signer } from "ethers";
import { Listener, Provider } from "ethers/providers";
import { Arrayish, BigNumber, BigNumberish, Interface } from "ethers/utils";
import { UnsignedTransaction } from "ethers/utils/transaction";
import { TypedEventDescription, TypedFunctionDescription } from ".";

interface StdErrorInterface extends Interface {
  functions: {
    arithmeticError: TypedFunctionDescription<{ encode([]: []): string }>;

    assertionError: TypedFunctionDescription<{ encode([]: []): string }>;

    divisionError: TypedFunctionDescription<{ encode([]: []): string }>;

    encodeStorageError: TypedFunctionDescription<{ encode([]: []): string }>;

    enumConversionError: TypedFunctionDescription<{ encode([]: []): string }>;

    indexOOBError: TypedFunctionDescription<{ encode([]: []): string }>;

    memOverflowError: TypedFunctionDescription<{ encode([]: []): string }>;

    popError: TypedFunctionDescription<{ encode([]: []): string }>;

    zeroVarError: TypedFunctionDescription<{ encode([]: []): string }>;
  };

  events: {};
}

export class StdError extends Contract {
  connect(signerOrProvider: Signer | Provider | string): StdError;
  attach(addressOrName: string): StdError;
  deployed(): Promise<StdError>;

  on(event: EventFilter | string, listener: Listener): StdError;
  once(event: EventFilter | string, listener: Listener): StdError;
  addListener(eventName: EventFilter | string, listener: Listener): StdError;
  removeAllListeners(eventName: EventFilter | string): StdError;
  removeListener(eventName: any, listener: Listener): StdError;

  interface: StdErrorInterface;

  functions: {
    arithmeticError(overrides?: UnsignedTransaction): Promise<string>;

    "arithmeticError()"(overrides?: UnsignedTransaction): Promise<string>;

    assertionError(overrides?: UnsignedTransaction): Promise<string>;

    "assertionError()"(overrides?: UnsignedTransaction): Promise<string>;

    divisionError(overrides?: UnsignedTransaction): Promise<string>;

    "divisionError()"(overrides?: UnsignedTransaction): Promise<string>;

    encodeStorageError(overrides?: UnsignedTransaction): Promise<string>;

    "encodeStorageError()"(overrides?: UnsignedTransaction): Promise<string>;

    enumConversionError(overrides?: UnsignedTransaction): Promise<string>;

    "enumConversionError()"(overrides?: UnsignedTransaction): Promise<string>;

    indexOOBError(overrides?: UnsignedTransaction): Promise<string>;

    "indexOOBError()"(overrides?: UnsignedTransaction): Promise<string>;

    memOverflowError(overrides?: UnsignedTransaction): Promise<string>;

    "memOverflowError()"(overrides?: UnsignedTransaction): Promise<string>;

    popError(overrides?: UnsignedTransaction): Promise<string>;

    "popError()"(overrides?: UnsignedTransaction): Promise<string>;

    zeroVarError(overrides?: UnsignedTransaction): Promise<string>;

    "zeroVarError()"(overrides?: UnsignedTransaction): Promise<string>;
  };

  arithmeticError(overrides?: UnsignedTransaction): Promise<string>;

  "arithmeticError()"(overrides?: UnsignedTransaction): Promise<string>;

  assertionError(overrides?: UnsignedTransaction): Promise<string>;

  "assertionError()"(overrides?: UnsignedTransaction): Promise<string>;

  divisionError(overrides?: UnsignedTransaction): Promise<string>;

  "divisionError()"(overrides?: UnsignedTransaction): Promise<string>;

  encodeStorageError(overrides?: UnsignedTransaction): Promise<string>;

  "encodeStorageError()"(overrides?: UnsignedTransaction): Promise<string>;

  enumConversionError(overrides?: UnsignedTransaction): Promise<string>;

  "enumConversionError()"(overrides?: UnsignedTransaction): Promise<string>;

  indexOOBError(overrides?: UnsignedTransaction): Promise<string>;

  "indexOOBError()"(overrides?: UnsignedTransaction): Promise<string>;

  memOverflowError(overrides?: UnsignedTransaction): Promise<string>;

  "memOverflowError()"(overrides?: UnsignedTransaction): Promise<string>;

  popError(overrides?: UnsignedTransaction): Promise<string>;

  "popError()"(overrides?: UnsignedTransaction): Promise<string>;

  zeroVarError(overrides?: UnsignedTransaction): Promise<string>;

  "zeroVarError()"(overrides?: UnsignedTransaction): Promise<string>;

  filters: {};

  estimate: {
    arithmeticError(overrides?: UnsignedTransaction): Promise<BigNumber>;

    "arithmeticError()"(overrides?: UnsignedTransaction): Promise<BigNumber>;

    assertionError(overrides?: UnsignedTransaction): Promise<BigNumber>;

    "assertionError()"(overrides?: UnsignedTransaction): Promise<BigNumber>;

    divisionError(overrides?: UnsignedTransaction): Promise<BigNumber>;

    "divisionError()"(overrides?: UnsignedTransaction): Promise<BigNumber>;

    encodeStorageError(overrides?: UnsignedTransaction): Promise<BigNumber>;

    "encodeStorageError()"(overrides?: UnsignedTransaction): Promise<BigNumber>;

    enumConversionError(overrides?: UnsignedTransaction): Promise<BigNumber>;

    "enumConversionError()"(
      overrides?: UnsignedTransaction
    ): Promise<BigNumber>;

    indexOOBError(overrides?: UnsignedTransaction): Promise<BigNumber>;

    "indexOOBError()"(overrides?: UnsignedTransaction): Promise<BigNumber>;

    memOverflowError(overrides?: UnsignedTransaction): Promise<BigNumber>;

    "memOverflowError()"(overrides?: UnsignedTransaction): Promise<BigNumber>;

    popError(overrides?: UnsignedTransaction): Promise<BigNumber>;

    "popError()"(overrides?: UnsignedTransaction): Promise<BigNumber>;

    zeroVarError(overrides?: UnsignedTransaction): Promise<BigNumber>;

    "zeroVarError()"(overrides?: UnsignedTransaction): Promise<BigNumber>;
  };
}
